package top.yatt.dfargx;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {

  public static void generateCppCheckerCode(RegexMatcher matcher, String filename) throws IOException {
    File file = new File("./out/" + filename + ".cpp");

    if (!file.exists()) {
      file.createNewFile();
    }

    PrintWriter pw = new PrintWriter(new FileWriter(file));

    pw.println("// #######################################################################");
    pw.println("// AUTOGENERATED FILE DON'T MODIFY.");
    pw.println("// FILE IS AUTOGENERATED FROM Main.java TO RECOGNIZE THE REGEX " + filename + ".");
    pw.println("// #######################################################################");
    pw.println("#include <iostream>");
    pw.println("#include <string>");
    pw.println();

    pw.println("int main(int argc, char* argv[]) {");
    pw.println("\tint is = " + matcher.getIs() + ";");
    pw.println("\tint rs = " + matcher.getRs() + ";");
    pw.print("\tbool fs[" + matcher.getFs().length + "] = {");
    for (boolean v : matcher.getFs()) {
      pw.print(v + ",");
    }
    pw.println("};");

    pw.println("\tint tt[" + matcher.getTransitionTable().length + "][" + matcher.getTransitionTable()[0].length + "] = {");
    for (int[] row: matcher.getTransitionTable()) {
      pw.print("\t\t{");
      for (int e: row) {
        pw.print( e + ",") ;
      }
      pw.println("},");
    }
    pw.println("\t};");

    pw.println("\tstd::string str(argv[1]);");

    // full matcher code
//    pw.println("int s = is;");
//    pw.println("for (int i = 0; i < str.size(); i++) {");
//    pw.println("s = tt[s][(int)(str[i])];");
//
//    pw.println("if (s == rs) {");
//    pw.println("std::cout << \"Failed\" << std::endl;");
//    pw.println("return 0;");
//    pw.println("}");
//
//    pw.println("}");
//
//    pw.println("std::cout << (fs[s] == 1 ? \"Matched\" : \"Failed\") << std::endl;");
//
//    pw.println("return 0;\n");
//    pw.println("}");

    // check all parts of string
    pw.println("\tint start_pos = 0;");

    // start while
    pw.println("\twhile (start_pos < str.size()) {");
    pw.println("\t\tint s = is;");

    // start for
    pw.println("\t\tfor (int i = start_pos; i < str.size(); i++) {");
    pw.println("\t\t\ts = tt[s][(int)(str[i])];");

    // start if
    pw.println("\t\t\tif (s == rs) {");
    pw.println("\t\t\t\tbreak;");
    pw.println("\t\t\t} else if (fs[s]) {");
    pw.println("\t\t\t\tstd::cout << \"Success!\" << std::endl;");
    pw.println("\t\t\t\treturn 0;");
    // end if
    pw.println("\t\t\t}");

    // end for
    pw.println("\t\t}");
    pw.println("\t\tstart_pos++;");

    // end while
    pw.println("\t}");

    pw.println("\tstd::cout << \"Failed\" << std::endl;");
    pw.println("\treturn 0;");
    pw.println("\t}");

    pw.flush();
  }

  private static void generateHeaders(PrintWriter pw, String regex) {
    pw.println("// #######################################################################");
    pw.println("// AUTOGENERATED FILE DON'T MODIFY.");
    pw.println("// FILE IS AUTOGENERATED FROM Main.java TO RECOGNIZE THE REGEX " + regex + ".");
    pw.println("// #######################################################################");
    pw.println("#include <iostream>");
    pw.println("#include <string>");
    pw.println();

    pw.println("int main(int argc, char* argv[]) {");
    pw.println("\tint result = -1;");
    pw.println("\tint idx = 0;");
    pw.println("\tchar c;");
    pw.println("\tstd::string str(argv[1]);");
  }

  private static void generateFooter(PrintWriter pw) {
    pw.println("}"); // end main
    pw.flush();
  }

  private static void generateState(Map<Character, Integer> stateMap, int state, boolean[] fs,
    int rs, PrintWriter pw) {
    pw.println("\tstate" + state + ":");

    if (fs[state]) {
      pw.println("\t\t// final state");
      pw.println("\t\tresult = idx;");
      pw.println("\t\tstd::cout << \"Found starting at:\" << result << std::endl;");
      pw.println("\t\treturn 0;");
      return;
    }

    if (state == rs) {
      pw.println("\t\t// reject state");
      pw.println("\t\tstd::cout << \"Failed to match:\" << result << std::endl;");
      pw.println("\t\treturn 0;");
      return;
    }
    // boundary check
    pw.println("\t\tif (str.size() <= idx) {");
    pw.println("\t\t\t std::cout << result << std::endl;");
    pw.println("\t\t\t return 0;");
    pw.println("\t\t}");

    pw.println("\t\tc = str[idx++];");
    for (Map.Entry<Character, Integer> entry : stateMap.entrySet()) {
      pw.println("\t\tif (c == '" + entry.getKey() + "') {");
      pw.println("\t\t\tgoto state" + entry.getValue() + ";");
      pw.println("\t\t}");
    }

    // no other condition matched
    pw.println("\t\tgoto state" + rs + ";");
  }

  private static PrintWriter getWriter(String filename) throws IOException {
    File file = new File("./out/" + filename + ".cpp");

    if (!file.exists()) {
      file.createNewFile();
    }

    return new PrintWriter(new FileWriter(file));
  }

  private static void generateCode(RegexMatcher matcher, String regex) throws IOException {
    // convert transition table to hashmap
    // [state_id] -> {"char": to_state_id}
    HashMap<Integer, Map<Character, Integer>> transitionMap = new HashMap<>();
    for (int i = 0; i < matcher.getTransitionTable().length; i++) {
      int[] stateTransition = matcher.getTransitionTable()[i];
      HashMap<Character, Integer> stateTransitions = new HashMap<>();
      for (int j = 0; j < stateTransition.length; j++) {
        if (stateTransition[j] != matcher.getRs()) {
          stateTransitions.put((char) j, stateTransition[j]);
        }
      }

      transitionMap.put(i, stateTransitions);
    }

    System.out.println(transitionMap);

    // create file writer
    PrintWriter pw = getWriter(regex);

    // headers
    generateHeaders(pw, regex);

    // generate initial state
    int is = matcher.getIs();
    boolean[] fs = matcher.getFs();
    int rs = matcher.getRs();

    generateState(transitionMap.get(is), is, fs, matcher.getRs(), pw);

    for (int i = 0; i < transitionMap.size(); i++) {
      if (i == is || i == rs) {
        continue;
      }
      generateState(transitionMap.get(i), i, fs, rs, pw);
    }

    generateState(transitionMap.get(rs), rs, fs, rs, pw);

    generateFooter(pw);
  }

  public static void main(String[] args) throws IOException {
    Scanner sc = new Scanner(System.in);
    String regex = sc.nextLine();

    RegexMatcher matcher = new RegexMatcher(regex);
    generateCode(matcher, regex);

  }
}
