package top.yatt.dfargx;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

public class Main {

  private static void generateHeaders(PrintWriter pw, boolean benchmarkMode, String regex) {
    pw.println("// #######################################################################");
    pw.println("// AUTOGENERATED FILE DON'T MODIFY.");
    pw.println("// FILE IS AUTOGENERATED FROM Main.java TO RECOGNIZE THE REGEX " + regex + ".");
    pw.println("// #######################################################################");
    pw.println("#include <iostream>");
    pw.println("#include <string>");
    if (benchmarkMode) {
      pw.println("#include <fstream>");
      pw.println("#include <sstream>");
      pw.println("#include <chrono>");
      pw.println("using namespace std::chrono;");
    }
    pw.println();
  }

  private static void generateMain(PrintWriter pw, boolean benchmarkMode) {
    pw.println("int main(int argc, char* argv[]) {");
    pw.println("  // load data");
    pw.println("  std::string str(argv[1]);");

    if (benchmarkMode) {
      pw.println("  std::ifstream st(str);");
      pw.println("  std::stringstream buf;");
      pw.println("  buf << st.rdbuf();");
      pw.println("  str = buf.str();");
    }
    pw.println();

    if (benchmarkMode) {
      pw.println("  auto start = high_resolution_clock::now();");
    }
    pw.println("  int matched = traverse(str);");
    pw.println("  auto end = high_resolution_clock::now();");
    pw.println("  std::cout << \"Matching Result: \" << matched << std::endl;");
    pw.println("  auto dur = duration_cast<microseconds>(end - start);");
    pw.println(
      "  std::cout << \"TimeToExecute: \" << dur.count() << \" microseconds.\" << std::endl;");
    pw.println("}");
    pw.println();
  }

  private static void generateDfaTraverse(PrintWriter pw,
    HashMap<Integer, Map<Integer, Integer>> transitionMap, RegexMatcher matcher,
    boolean benchmarkMode, String regex) {
    pw.println("bool traverse(std::string& str) {");

    pw.println("  int result = -1;");
    pw.println("  int idx = 0;");
    pw.println("  int c;");
    pw.println();

    // generate initial state
    int is = matcher.getIs();
    boolean[] fs = matcher.getFs();
    int rs = matcher.getRs();

    generateState(transitionMap.get(is), is, fs, matcher.getRs(), pw);

    for (int i = 0; i < transitionMap.size(); i++) {
      if (i == is || i == rs) {
        continue;
      }
      generateState(transitionMap.get(i), i, fs, rs, pw);
    }

    generateState(transitionMap.get(rs), rs, fs, rs, pw);

    pw.println("}");
    pw.println();
  }

  private static void groupByValue(Map<Integer, Integer> originalMap) {
    Map<Integer, List<Integer>> resultMap = originalMap.entrySet().stream()
      .collect(Collectors.groupingBy(Map.Entry::getValue,
        Collectors.mapping(Map.Entry::getKey, Collectors.toList())));
    resultMap.forEach((k, v) -> System.out.println(k + ":" + v.size()));
  }

  private static void genRange(PrintWriter pw, int startRange, int endRange, int v) {
    if (endRange - startRange == 0) {
      pw.print("    if (c == " + startRange + ") ");
      pw.println("goto state" + v + ";");
    } else {
      // actual range
      pw.print("    if (c >= " + startRange + " && c <= " + endRange + ") ");
      pw.println("goto state" + v + ";");
    }
  }

  private static void generateState(Map<Integer, Integer> stateMap, int state, boolean[] fs,
    int rs, PrintWriter pw) {
    pw.println("  state" + state + ":");

    if (fs[state]) {
      pw.println("    // final state");
      pw.println("    result = idx;");
      pw.println("    std::cout << \"Found ending at:\" << result << std::endl;");
      pw.println("    return true;");
      return;
    }

    if (state == rs) {
      pw.println("    // reject state");
      pw.println("    std::cout << \"Failed to match:\" << result << std::endl;");
      pw.println("    return false;");
      return;
    }
    // boundary check
    pw.println("    if (str.size() <= idx) {");
    pw.println("       std::cout << \"Input ended before a match is found.\" << std::endl;");
    pw.println("       return false;");
    pw.println("    }");

    pw.println("    c = (int)(str[idx++]);");

    int prev = -1;
    int startRange = -1;
    int endRange = -1;

    Integer[] keys = stateMap.keySet().toArray(new Integer[0]);
    Arrays.sort(keys);
    System.out.println("State: " + state);
    for (int i = 0; i < keys.length; i++) {
      if (i == 0) {
        startRange = endRange = keys[i];
        prev = stateMap.get(startRange);
        continue;
      }
      int key = keys[i];
      int v = stateMap.get(key);
      if (v == prev && (key == keys[i - 1] + 1)) {
        endRange = key;
      } else {
        // new range print old range
        System.out.println(
          "Found Range: [" + startRange + ", " + endRange + "] -> goto state: " + prev);
        // single range
        genRange(pw, startRange, endRange, prev);
        startRange = endRange = key;
      }
      prev = v;
    }

    System.out.println(
      "Found Last Range: [" + startRange + ", " + endRange + "] -> goto state: " + prev);
    genRange(pw, startRange, endRange, prev);

    // no other condition matched
    pw.println("    goto state" + rs + ";");
  }

  private static PrintWriter getWriter(String filename) throws IOException {
    String s = filename.replace("\\", "");

    File file = new File("./out/" + s + ".cpp");

    if (!file.exists()) {
      file.createNewFile();
    }

    return new PrintWriter(new FileWriter(file));
  }

  private static void generateCode(RegexMatcher matcher, boolean benchmarkMode, String regex)
    throws IOException {
    // convert transition table to hashmap
    // [state_id] -> {"char": to_state_id}
    HashMap<Integer, Map<Integer, Integer>> transitionMap = new HashMap<>();
    for (int i = 0; i < matcher.getTransitionTable().length; i++) {
      int[] stateTransition = matcher.getTransitionTable()[i];
      HashMap<Integer, Integer> stateTransitions = new HashMap<>();
      for (int j = 0; j < stateTransition.length; j++) {
        if (stateTransition[j] != matcher.getRs()) {
          stateTransitions.put(j, stateTransition[j]);
        }
      }

      transitionMap.put(i, stateTransitions);
    }

    System.out.println("Transition Map: ");
    transitionMap.forEach((k, v) -> System.out.println(k + ": " + v));
    // create file writer
    PrintWriter pw = getWriter(regex);

    // headers
    generateHeaders(pw, benchmarkMode, regex);

    generateDfaTraverse(pw, transitionMap, matcher, benchmarkMode, regex);

    generateMain(pw, benchmarkMode);

    pw.flush();
  }

  public static void main(String[] args) throws IOException {
    Scanner sc = new Scanner(System.in);
    String regex = sc.nextLine();

    // allow fast partial matching
    // would be changed if we support lineStart and lineEnd.
    boolean matchPartial = false;
//    boolean matchPartial = true;
    if (matchPartial) {
      regex = ".*(" + regex + ").*";
    }
    // makes the code load data from file
    // and measures execution time
    boolean benchmarkMode = true;
    RegexMatcher matcher = new RegexMatcher(regex);
    generateCode(matcher, benchmarkMode, regex);


  }
}
